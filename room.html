<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Interlinked — Stanza</title>
  <!-- Lucide Icons -->
  <script src="https://unpkg.com/lucide@latest"></script>
  <style>
    :root {
      --gap: 12px;
      --bg-dark: #0b0f19;
      --bg-card: #141a2a;
      --bg-hover: #1b2235;
      --border: #2c344a;
      --accent: #3b82f6;
      --accent-hover: #2563eb;
      --text: #e5e7eb;
      --text-muted: #94a3b8;
      --danger: #ef4444;
      --success: #10b981;
    }
    * { box-sizing: border-box; margin:0; padding:0; }
    html, body { 
      height:100%; 
      background: var(--bg-dark); 
      color: var(--text);
      font-family: 'Inter', ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      overflow: hidden;
      padding-top: 60px;
      padding-top: 14px;
    }
    .app { 
      height:100%; 
      display:flex; 
      flex-direction:column; 
      padding:var(--gap); 
      gap:var(--gap); 
      animation: slideUp 0.6s ease-out;
      position: relative;
      z-index: 1;
    }
    
    @keyframes slideUp {
      from {
        opacity: 0;
        transform: translateY(30px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    /* Topbar */
    .topbar { 
      display:grid; 
      grid-template-columns:40px 1fr 40px; 
      align-items:center;
      padding:12px 16px; 
      border:1px solid var(--border); 
      border-radius:14px; 
      background: var(--bg-card);
      box-shadow: 0 4px 16px rgba(0,0,0,.4);
      flex-shrink:0; 
      animation: fadeIn 0.8s ease-out;
      animation-delay: 0.1s;
      animation-fill-mode: both;
      position: relative;
      z-index: 100;
    }
    
    .iconbtn { 
      display:grid; 
      place-items:center; 
      width:38px; 
      height:38px;
      border-radius:12px; 
      border:1px solid var(--border); 
      background: var(--bg-card); 
      cursor:pointer; 
      color:var(--text); 
      font-size:20px;
      transition: background .2s, transform .2s;
    }
    .iconbtn:hover { 
      background: var(--bg-hover); 
      transform: scale(1.04);
      box-shadow: 0 4px 12px rgba(0,0,0,.3);
    }
    
    .username { 
      text-align:center; 
      font-weight:700; 
      font-size:1.1rem;
      display:flex; 
      align-items:center; 
      justify-content:center; 
      gap:8px; 
      color: var(--accent);
      animation: fadeIn 0.8s ease-out;
      animation-delay: 0.2s;
      animation-fill-mode: both;
    }
    
    .presence-dot { 
      width:10px; 
      height:10px; 
      border-radius:50%; 
      display:inline-block; 
      background:var(--danger); 
      box-shadow:0 0 8px rgba(0,0,0,.4);
      transition: background .3s ease;
    }
    .presence-on { 
      background:var(--success) !important; 
      animation: pulse 1.5s infinite;
      box-shadow:0 0 12px rgba(16, 185, 129, 0.6);
    }
    
    @keyframes pulse {
      0%, 100% { 
        opacity: 1; 
        transform: scale(1);
        box-shadow:0 0 12px rgba(16, 185, 129, 0.6);
      }
      50% { 
        opacity: 0.6; 
        transform: scale(1.2);
        box-shadow:0 0 20px rgba(16, 185, 129, 0.8);
      }
    }
    
    .kebab { 
      font-size:22px; 
      line-height:0; 
      color:var(--text); 
    }
    
    .menu { 
      position:relative; 
      justify-self:end; 
      z-index: 9999;
    }
    
    .menu .panel { 
      position:absolute; 
      right:0; 
      top:48px; 
      min-width:220px; 
      padding:8px; 
      border:1px solid var(--border);
      background: var(--bg-card); 
      border-radius:12px; 
      display:none; 
      z-index: 9999; 
      box-shadow:0 12px 30px rgba(0,0,0,.5);
      animation: fadeIn 0.2s ease-out;
      transform-origin: top right;
    }
    .menu.open .panel { 
      display:block; 
    }
    
    .row { 
      display:flex; 
      align-items:center; 
      justify-content:space-between; 
      gap:8px; 
      font-size:13px; 
      padding:6px 0; 
      color: var(--text);
      border-radius: 8px;
      transition: background .2s;
    }
    
    .row:hover {
      background: var(--bg-hover);
      padding: 6px 4px;
      margin: 0 -4px;
      transform: translateX(4px);
      box-shadow: 0 2px 8px rgba(0,0,0,.2);
    }
    
    input[type="color"] { 
      inline-size:46px; 
      block-size:32px; 
      padding:0; 
      border:none; 
      background:transparent; 
      border-radius:8px;
      cursor: pointer;
    }
    
    input[type="range"] {
      background: var(--bg-hover);
      border-radius: 6px;
      height: 6px;
      outline: none;
      cursor: pointer;
    }
    
    input[type="range"]::-webkit-slider-thumb {
      appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: var(--accent);
      cursor: pointer;
    }
    
    input[type="range"]::-moz-range-thumb {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: var(--accent);
      border: none;
      cursor: pointer;
    }
    
    input[type="checkbox"] {
      appearance: none;
      width: 16px;
      height: 16px;
      border: 2px solid var(--border);
      border-radius: 4px;
      background: var(--bg-card);
      cursor: pointer;
      position: relative;
      transition: all .2s;
    }
    
    input[type="checkbox"]:checked {
      background: var(--accent);
      border-color: var(--accent);
    }
    
    input[type="checkbox"]:checked::after {
      content: '✓';
      position: absolute;
      top: -2px;
      left: 1px;
      color: white;
      font-size: 12px;
      font-weight: bold;
    }

    /* Pro Features Overlay */
    .pro-feature {
      position: relative;
    }

    .pro-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(11, 15, 25, 0.8);
      backdrop-filter: blur(4px);
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: opacity 0.3s ease;
      pointer-events: none;
      cursor: pointer;
    }

    .pro-feature:hover .pro-overlay {
      opacity: 1;
    }

    /* Always visible overlay for free users */
    .pro-feature.free-user .pro-overlay {
      opacity: 1;
      pointer-events: all;
    }

    /* Pro controls group styling */
    .pro-controls-group {
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 8px;
      margin: 8px 0;
      background: rgba(20, 26, 42, 0.3);
    }

    /* Responsive menu */
    @media (max-width: 480px) {
      .menu .panel {
        min-width: 200px;
        padding: 6px;
        right: -10px;
      }
      
      .row {
        font-size: 12px;
        padding: 4px 0;
        gap: 6px;
      }
      
      .row:hover {
        padding: 4px 2px;
      }
      
      input[type="color"] {
        inline-size: 40px;
        block-size: 28px;
      }
      
      input[type="range"] {
        height: 4px;
      }
      
      input[type="range"]::-webkit-slider-thumb {
        width: 14px;
        height: 14px;
      }
      
      input[type="range"]::-moz-range-thumb {
        width: 14px;
        height: 14px;
      }
      
      .pro-controls-group {
        padding: 6px;
        margin: 6px 0;
      }
    }

    @media (max-width: 360px) {
      .menu .panel {
        min-width: 180px;
        padding: 4px;
        right: -15px;
      }
      
      .row {
        font-size: 11px;
        padding: 3px 0;
        gap: 4px;
      }
      
      .row:hover {
        padding: 3px 1px;
      }
      
      input[type="color"] {
        inline-size: 36px;
        block-size: 24px;
      }
      
      .pro-controls-group {
        padding: 4px;
        margin: 4px 0;
      }
    }

    .pro-crown {
      color: #fbbf24;
      font-size: 24px;
      animation: pulse 2s infinite;
    }

    .pro-crown svg {
      width: 24px;
      height: 24px;
      filter: drop-shadow(0 0 8px rgba(251, 191, 36, 0.5));
    }

    @keyframes pulse {
      0%, 100% { 
        transform: scale(1);
        opacity: 1;
      }
      50% { 
        transform: scale(1.1);
        opacity: 0.8;
      }
    }
    
    .controls { 
      display:flex; 
      align-items:center; 
      gap:10px; 
      flex-wrap:wrap; 
      flex-shrink:0; 
      animation: fadeIn 0.8s ease-out;
      animation-delay: 0.3s;
      animation-fill-mode: both;
    }
    
    .pill { 
      padding:8px 12px; 
      border:1px solid var(--border); 
      border-radius:12px; 
      background: var(--bg-card); 
      display:inline-flex; 
      gap:6px; 
      align-items:center;
      font-size: 14px;
      font-weight: 500;
      box-shadow: 0 2px 8px rgba(0,0,0,.2);
      transition: all 0.2s ease;
    }
    
    .pill:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(0,0,0,.3);
    }
    
    .small { 
      font-size:12px; 
      color:var(--text-muted); 
    }
    
    .file-btn { 
      display:grid; 
      place-items:center; 
      width:36px; 
      height:36px; 
      border:1px solid var(--border); 
      border-radius:10px; 
      background: var(--bg-hover); 
      cursor:pointer; 
      color:var(--text-muted);
      transition: background .2s, color .2s;
    }
    .file-btn:hover { 
      background: var(--accent); 
      color:var(--text); 
      transform: scale(1.05);
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
    }
    .file-btn svg { 
      width:18px; 
      height:18px; 
    }
    
    /* Modal/Toast */
    .ui-modal-bg{
      position:fixed;
      inset:0;
      background:rgba(0,0,0,.6);
      display:none;
      align-items:center;
      justify-content:center;
      z-index:100
    }
    .ui-modal{
      background:var(--bg-card);
      border:1px solid var(--border);
      border-radius:14px;
      padding:16px;
      max-width:420px;
      width:90%;
      box-shadow:0 16px 40px rgba(0,0,0,.5);
      display:flex;
      flex-direction:column;
      gap:12px
    }
    .ui-actions{
      display:flex;
      gap:8px;
      justify-content:flex-end
    }
    .ui-btn{
      padding:10px 14px;
      border-radius:10px;
      border:1px solid var(--border);
      background:var(--bg-hover);
      color:var(--text);
      cursor:pointer;
      transition: background .2s;
    }
    .ui-btn:hover {
      background: var(--accent);
      color: white;
    }
    .ui-btn.primary{
      background:var(--accent);
      border-color:var(--accent);
      color:#fff
    }
    .ui-btn.primary:hover {
      background: var(--accent-hover);
    }
    
    .ok { color:var(--success); } 
    .warn { color:#fbbf24; }
    
    .mono { 
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace; 
    }
    
    .btn { 
      padding:8px 12px; 
      border-radius:10px; 
      border:1px solid var(--border); 
      background: var(--bg-hover); 
      color:var(--text); 
      cursor:pointer;
      transition: background .2s;
    }
    .btn:hover { 
      background: var(--accent); 
      color: white;
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(59, 130, 246, 0.3);
    }
    
    .stage { 
      position:relative; 
      flex:1; 
      border:1px solid var(--border); 
      border-radius:14px; 
      overflow:hidden; 
      background: var(--bg-card);
      box-shadow: 0 4px 16px rgba(0,0,0,.4);
      animation: fadeIn 0.8s ease-out;
      animation-delay: 0.4s;
      animation-fill-mode: both;
      z-index: 1;
    }
    
    canvas { 
      position:absolute; 
      inset:0; 
      width:100%; 
      height:100%; 
      image-rendering: pixelated; 
      transition: all 0.3s ease;
      z-index: 1;
    }
    
    /* Mobile optimizations */
    @media (max-height: 700px) {
      body {
        padding-top: 50px;
      }
    }
    
    @media (max-height: 600px) {
      body {
        padding-top: 40px;
      }
    }

    @media (max-width:520px){
      .topbar{ flex-direction:row; gap:8px; }
    }

    /* Animations */
    @keyframes fadeIn { 
      from{opacity:0; transform:translateY(-6px);} 
      to{opacity:1; transform:translateY(0);} 
    }
  </style>
</head>
<body>
  <div class="app">
    <!-- Topbar -->
    <div class="topbar">
      <button class="iconbtn" id="back" title="Indietro" aria-label="Indietro"><i data-lucide="arrow-left"></i></button>
      <div class="username" id="user"><span id="userName">stanza</span> <span id="presenceDot" class="presence-dot" title="Offline"></span></div>
      <div class="menu" id="menu">
        <button class="iconbtn kebab" aria-haspopup="true" aria-expanded="false" title="Menu rapido"><i data-lucide="more-vertical"></i></button>
        <div class="panel" role="menu">
          <div class="row"><span>Cambia colore</span><input type="color" id="color" value="#00ffaa"></div>
          <div class="pro-feature pro-controls-group" data-feature="advanced-controls">
            <div class="row" style="margin-top:8px">
              <label>Spaziatura puntini
                <input type="range" id="spacing" min="10" max="40" step="2" value="18"></label>
            </div>
            <div class="row" style="margin-top:8px">
              <label>Raggio effetto
                <input type="range" id="radius" min="20" max="200" step="4" value="90"></label>
            </div>
            <div class="row" style="margin-top:8px">
              <label>Durata scia (ms)
                <input type="range" id="life" min="400" max="4000" step="100" value="2000"></label>
            </div>
            <div class="pro-overlay">
              <div class="pro-crown">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M12 2L15.09 8.26L22 9L17 14L18.18 21L12 17.77L5.82 21L7 14L2 9L8.91 8.26L12 2Z"/>
                </svg>
              </div>
            </div>
          </div>
          <hr style="border:none;border-top:1px solid #334155;margin:6px 0">
          <div class="row"><span>Suono interazione</span>
            <label class="small"><input type="checkbox" id="soundEnabled" checked> Attivo</label>
          </div>
          <div class="row"><label>Volume
            <input type="range" id="soundVol" min="0" max="1" step="0.05" value="0.4"></label></div>
          <hr style="border:none;border-top:1px solid #334155;margin:6px 0">
          <div class="row"><span>Vibrazione</span>
            <label class="small"><input type="checkbox" id="vibrationEnabled" checked> Attiva</label>
          </div>
          <div class="row pro-feature" data-feature="custom-sound">
            <span>Carica suono (mp3 ≤ 5s)</span>
            <input type="file" id="soundFile" accept="audio/mpeg" style="display:none">
            <button id="fileBtn" class="file-btn" title="Carica">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                <polyline points="7 10 12 5 17 10"/>
                <line x1="12" y1="5" x2="12" y2="20"/>
              </svg>
            </button>
            <div class="pro-overlay">
              <div class="pro-crown">
                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                  <path d="M12 2L15.09 8.26L22 9L17 14L18.18 21L12 17.77L5.82 21L7 14L2 9L8.91 8.26L12 2Z"/>
                </svg>
              </div>
            </div>
          </div>
          <div class="row"><button class="btn" id="resetBtn">Reset</button></div>
        </div>
      </div>
    </div>

    <!-- Seconda riga: LIVE indicator only -->
    <div class="controls">
      <span class="pill">LIVE: <b id="rtFlag" class="warn">OFF</b></span>
    </div>

    <!-- Canvas -->
    <div class="stage">
      <canvas id="dots"></canvas>
    </div>
  </div>

  <!-- Firebase -->
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-database-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.0/firebase-auth-compat.js"></script>

  <script>
    // === Config identica ===
    window.FIREBASE_CONFIG = {
      apiKey: "AIzaSyDgqD_R_L-qgIaFGB_c9qJRID0KV9jgLPY",
      authDomain: "interlinked-b5d13.firebaseapp.com",
      databaseURL: "https://interlinked-b5d13-default-rtdb.europe-west1.firebasedatabase.app",
      projectId: "interlinked-b5d13",
      storageBucket: "interlinked-b5d13.firebasestorage.app",
      messagingSenderId: "146726521975",
      appId: "1:146726521975:web:f42bbfe0c1207a1ac14a72",
      measurementId: "G-79V9PFWB4E"
    };
    firebase.initializeApp(window.FIREBASE_CONFIG);
    const db = firebase.database();
    const auth = firebase.auth();

    // Gate: se non loggato torna al login
    auth.onAuthStateChanged(async (u) => { 
      if(!u) location.replace('login.html');
      else {
        await loadUserSubscription();
        updateProFeatures();
      }
    });

    // Back ai contatti
    document.getElementById("back").addEventListener("click", ()=> location.href='index.html');

    // Load user subscription
    async function loadUserSubscription() {
      try {
        const user = auth.currentUser;
        if (!user) return;
        
        const subscriptionSnap = await db.ref(`users/${user.uid}/subscription`).once('value');
        const subscription = subscriptionSnap.val();
        
        if (subscription && subscription.status === 'active') {
          userSubscription = {
            plan: subscription.plan,
            expiresAt: subscription.expiresAt,
            status: subscription.status
          };
        } else {
          userSubscription = { plan: 'free', status: 'active' };
        }
      } catch (error) {
        console.error('Error loading subscription:', error);
        userSubscription = { plan: 'free', status: 'active' };
      }
    }

    // Update pro features based on subscription
    function updateProFeatures() {
      const isPro = userSubscription && userSubscription.plan === 'pro';
      
      // Enable/disable pro features
      document.querySelectorAll('.pro-feature').forEach(feature => {
        const inputs = feature.querySelectorAll('input, button');
        inputs.forEach(input => {
          input.disabled = !isPro;
        });
        
        // Show/hide overlay
        const overlay = feature.querySelector('.pro-overlay');
        if (overlay) {
          overlay.style.display = isPro ? 'none' : 'flex';
        }
        
        // Add/remove free-user class for always visible overlay
        if (!isPro) {
          feature.classList.add('free-user');
          // Add click handler for non-pro users
          feature.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            location.href = 'plans.html';
          });
        } else {
          feature.classList.remove('free-user');
        }
      });
    }

    /************ UTIL ************/
    const $ = s => document.querySelector(s);
    const clamp = (n,a,b)=>Math.max(a,Math.min(b,n));
    const rndId = () => Math.random().toString(36).slice(2,10);
    const lerp = (a,b,t)=>a+(b-a)*t;
    function hexToRgb(h){ const x=h.replace('#',''); return { r:parseInt(x.slice(0,2),16), g:parseInt(x.slice(2,4),16), b:parseInt(x.slice(4,6),16) }; }
    function rgbStr({r,g,b,a=1}){ return `rgba(${r|0},${g|0},${b|0},${a})`; }

    /************ STATE ************/
    const canvas = $('#dots');
    const ctx = canvas.getContext('2d',{ alpha:true });
    ctx.imageSmoothingEnabled = false;

    const BG = getComputedStyle(document.documentElement).getPropertyValue('--bg-card').trim();
    const BASE_INSIDE = {r:255,g:255,b:255,a:0.85};
    const BASE_OUT    = {r:255,g:0,b:0,a:0.30};

    let zonePath = new Path2D();
    let points = [];
    let COLS=0, ROWS=0;
    let COLOR = '#00ffaa';
    let SPACING = 18;
    let RADIUS  = 90;
    let LIFE_MS = 2000;

    // Sound state
    let SOUND_ENABLED = true;
    let SOUND_VOLUME = 0.4;
    let audioCtx = null;
    let defaultBuffer = null; // default gentle click/chime
    let customBuffer = null;
    let lastSoundAt = 0;
    const SOUND_THROTTLE_MS = 80; // avoid overwhelming clicks
    let audioPrimed = false;

    // Vibration state
    let VIBRATION_ENABLED = true;
    let lastVibrationAt = 0;
    const VIBRATION_THROTTLE_MS = 100; // avoid overwhelming vibrations
    let vibrationPrimed = false;

    const CLIENT = 'c_' + rndId();
    const ROOM = (location.hash && location.hash.slice(1)) || ('room_' + rndId());
    if (!location.hash) history.replaceState(null, '', location.pathname + '#' + ROOM);
    // Try to resolve a friendly name for this room by scanning current user's contacts
    try {
      firebase.auth().onAuthStateChanged(async (u)=>{
        if (!u) return;
        const snap = await firebase.database().ref('users/'+u.uid+'/contacts').once('value');
        const contacts = snap.val() || {};
        let display = null;
        for (const k in contacts){
          const c = contacts[k];
          if (c && c.room === ROOM){ display = c.name || null; break; }
        }
        const nameEl = document.getElementById('userName');
        if (nameEl) nameEl.textContent = display ? display : ('Stanza ' + ROOM);
      });
    } catch(_){ const nameEl = document.getElementById('userName'); if (nameEl) nameEl.textContent = 'Stanza ' + ROOM; }

    let RT = { enabled:false, db:null };
    let userSubscription = null;

    /************ GRIGLIA ************/
    function resizeCanvas(){
      canvas.width  = canvas.clientWidth;
      canvas.height = canvas.clientHeight;
      buildZone();
    }
    function buildZone(){
      zonePath = new Path2D();
      const x=0, y=0, w=canvas.width, h=canvas.height, r=20;
      zonePath.moveTo(x+r,y);
      zonePath.arcTo(x+w,y,x+w,y+r,r);
      zonePath.arcTo(x+w,y+h,x+w-r,y+h,r);
      zonePath.arcTo(x,y+h,x,y+h-r,r);
      zonePath.arcTo(x,y,x+r,y,r);

      points = [];
      COLS = Math.floor(w / SPACING) + 1;
      ROWS = Math.floor(h / SPACING) + 1;
      for (let row=0; row<ROWS; row++){
        for (let col=0; col<COLS; col++){
          const px = col*SPACING, py = row*SPACING;
          points.push({ x:px, y:py, inside: ctx.isPointInPath(zonePath, px, py), heat: 0, col: {r:255,g:255,b:255} });
        }
      }
    }
    function applyBrush(cx, cy, colorHex=COLOR, radius=RADIUS){
      const col = hexToRgb(colorHex);
      const minCol = clamp(Math.floor((cx - radius)/SPACING), 0, COLS-1);
      const maxCol = clamp(Math.ceil ((cx + radius)/SPACING), 0, COLS-1);
      const minRow = clamp(Math.floor((cy - radius)/SPACING), 0, ROWS-1);
      const maxRow = clamp(Math.ceil ((cy + radius)/SPACING), 0, ROWS-1);
      for (let row=minRow; row<=maxRow; row++){
        for (let colIdx=minCol; colIdx<=maxCol; colIdx++){
          const i = row*COLS + colIdx;
          const p = points[i]; if (!p) continue;
          const dx = p.x - cx, dy = p.y - cy;
          const d = Math.hypot(dx,dy);
          if (d <= radius){
            const k = 1 - (d / radius);
            const influence = k*k;
            if (influence > p.heat){ p.heat = influence; p.col = col; }
          }
        }
      }
    }

    // ===== Sound helpers =====
    function ensureAudio(){
      if (!audioPrimed) return false;
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      if (audioCtx.state === 'suspended') {
        audioCtx.resume().catch(()=>{});
      }
      return true;
    }

    // ===== Vibration helpers =====
    function ensureVibration(){
      if (!vibrationPrimed) return false;
      return typeof Android !== 'undefined' && Android.hasVibrator && Android.hasVibrator();
    }
    
    function triggerVibration(){
      try{
        if (!VIBRATION_ENABLED || !vibrationPrimed) return;
        const nowMs = performance.now();
        if (nowMs - lastVibrationAt < VIBRATION_THROTTLE_MS) return;
        if (!ensureVibration()) return;
        lastVibrationAt = nowMs;
        // Fixed vibration duration (100ms)
        Android.vibrate(100);
      }catch(_){ /* never block interaction */ }
    }
    function playSound(){
      try{
        if (!SOUND_ENABLED || !audioPrimed) return;
        const nowMs = performance.now();
        if (nowMs - lastSoundAt < SOUND_THROTTLE_MS) return;
        if (!ensureAudio() || !audioCtx) return;
        const buffer = (customBuffer || defaultBuffer);
        if (!buffer) return;
        lastSoundAt = nowMs;
        const src = audioCtx.createBufferSource();
        src.buffer = buffer;
        const gain = audioCtx.createGain();
        gain.gain.value = SOUND_VOLUME;
        src.connect(gain).connect(audioCtx.destination);
        src.start();
      }catch(_){ /* never block interaction */ }
    }
    async function loadDefaultTone(){
      try{
        if (!ensureAudio()) return;
        // Generate a deeper, relaxing chime: 220Hz + 440Hz gentle attack and long decay (~350ms)
        const sr = audioCtx.sampleRate;
        const len = Math.floor(sr * 0.1); // longer ~600ms
        const buf = audioCtx.createBuffer(1, len, sr);
        const data = buf.getChannelData(0);
        const f1 = 80, f2 = 160, f3 = 90; // deeper and slight detune
        let lastNoise = 0;
        for (let i=0;i<len;i++){
          const t = i / sr;
          const attack = Math.min(1, t*3); // smooth attack
          const decay = Math.exp(-t*1.6);  // long decay
          // multi-sine + lowpassed/brownish noise for brrrr
          const tone = (Math.sin(2*Math.PI*f1*t) * 0.65 + Math.sin(2*Math.PI*f2*t) * 0.25 + Math.sin(2*Math.PI*f3*t) * 0.1);
          // Brown-ish noise
          const white = Math.random()*2-1;
          lastNoise = (lastNoise + (0.02*white)) / 1.02;
          const noise = lastNoise * 0.2 * Math.exp(-t*6);
          const trem = 1 + 0.03*Math.sin(2*Math.PI*7*t);
          const damp = attack * decay * trem;
          data[i] = (tone + noise) * damp * 0.7;
        }
        defaultBuffer = buf;
      }catch(e){ /* ignore */ }
    }
    async function fileToBuffer(file){
      ensureAudio();
      const array = await file.arrayBuffer();
      return await audioCtx.decodeAudioData(array);
    }

    /************ RENDER ************/
    let lastTime = performance.now();
    function drawFrame(){
      const now = performance.now();
      const dt = now - lastTime; lastTime = now;
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.save(); ctx.fillStyle = BG; ctx.fill(zonePath); ctx.restore();
      for (let i=0;i<points.length;i++){
        const p = points[i];
        if (p.heat > 0) p.heat = Math.max(0, p.heat - (dt / LIFE_MS));
        const size = 2 + p.heat * (2 * 3.2);
        const base = p.inside ? BASE_INSIDE : BASE_OUT;
        const r = p.inside ? lerp(base.r, p.col.r, p.heat) : (p.heat>0 ? lerp(base.r, p.col.r, p.heat) : base.r);
        const g = p.inside ? lerp(base.g, p.col.g, p.heat) : (p.heat>0 ? lerp(base.g, p.col.g, p.heat) : base.g);
        const b = p.inside ? lerp(base.b, p.col.b, p.heat) : (p.heat>0 ? lerp(base.b, p.col.b, p.heat) : base.b);
        const a = base.a;
        ctx.beginPath();
        ctx.arc(p.x+0.5, p.y+0.5, size, 0, Math.PI*2);
        ctx.fillStyle = rgbStr({r,g,b,a});
        ctx.fill();
      }
      requestAnimationFrame(drawFrame);
    }

    /************ INPUT ************/
    function toCanvasPos(evt){
      const r = canvas.getBoundingClientRect();
      const clientX = (evt.clientX ?? evt.touches?.[0]?.clientX);
      const clientY = (evt.clientY ?? evt.touches?.[0]?.clientY);
      const x = (clientX - r.left) * (canvas.width / r.width);
      const y = (clientY - r.top)  * (canvas.height / r.height);
      return { x: clamp(x,0,canvas.width-1), y: clamp(y,0,canvas.height-1) };
    }
    function sendHover(x,y){
      applyBrush(x,y,COLOR,RADIUS);
      playSound();
      if (RT.enabled && RT.db) {
        try{
          RT.db.ref('rooms/'+ROOM+'/events').push({
            type:'hover', payload:{x,y,r:RADIUS,c: COLOR}, client: CLIENT, ts: Date.now()
          });
          
          // Trigger notification for friends in this room
          triggerFriendNotification();
        }catch(_){ /* ignore */ }
      }
    }
    
    // Track last notification time to avoid spam (5 minutes per friend)
    let lastNotificationTimes = {};
    
    async function triggerFriendNotification() {
      try {
        const user = auth.currentUser;
        if (!user) return;
        
        const now = Date.now();
        const fiveMinutes = 5 * 60 * 1000; // 5 minutes in milliseconds
        
        // Get all users in this room
        const presenceRef = db.ref('rooms/'+ROOM+'/presence');
        const presenceSnap = await presenceRef.once('value');
        const presence = presenceSnap.val() || {};
        
        // Get current user's friends
        const friendsSnap = await db.ref('users/'+user.uid+'/contacts').once('value');
        const friends = friendsSnap.val() || {};
        
        // Find friends who are in this room
        const friendsInRoom = [];
        for (const [friendId, friendData] of Object.entries(friends)) {
          if (friendData && friendData.room === ROOM) {
            // Check if this friend is currently online in the room
            for (const [clientId, clientData] of Object.entries(presence)) {
              if (clientId !== CLIENT && clientData && clientData.ts) {
                const timeDiff = now - clientData.ts;
                if (timeDiff <= 10000) { // Online in last 10 seconds
                  // This could be our friend - we need to check if the client belongs to the friend
                  // For now, we'll assume any other client in the room is a friend
                  const notificationKey = `${friendId}_${ROOM}`;
                  if (!lastNotificationTimes[notificationKey] || 
                      (now - lastNotificationTimes[notificationKey]) > fiveMinutes) {
                    
                    friendsInRoom.push({
                      id: friendId,
                      name: friendData.name || 'Friend',
                      notificationKey: notificationKey
                    });
                  }
                }
              }
            }
          }
        }
        
        // Send notifications to friends
        for (const friend of friendsInRoom) {
          await sendNotificationToFriend(friend.id, friend.name);
          lastNotificationTimes[friend.notificationKey] = now;
        }
        
      } catch (error) {
        console.error('Error triggering friend notification:', error);
      }
    }
    
    async function sendNotificationToFriend(friendId, friendName) {
      try {
        // Create a notification entry in Firebase Database
        // The friend's web app will listen for these notifications
        await db.ref('notifications/'+friendId).push({
          type: 'friend_activity',
          friendName: friendName,
          roomId: ROOM,
          fromUserId: auth.currentUser.uid,
          timestamp: Date.now(),
          read: false
        });
        
        console.log('Notification sent to friend:', friendName);
        
      } catch (error) {
        console.error('Error sending notification to friend:', error);
      }
    }
    const menuEl = $('#menu');
    menuEl.querySelector('button.kebab').addEventListener('click', ()=>{
      menuEl.classList.toggle('open');
      menuEl.querySelector('button.kebab').setAttribute('aria-expanded', menuEl.classList.contains('open'));
    });
    document.addEventListener('click', (e)=>{ if (!menuEl.contains(e.target)) menuEl.classList.remove('open'); });

    $('#color').addEventListener('input', e=> COLOR = e.target.value);
    $('#spacing').addEventListener('input', e=>{ SPACING = parseInt(e.target.value,10); buildZone(); });
    $('#radius').addEventListener('input', e=> RADIUS = parseInt(e.target.value,10));
    $('#life').addEventListener('input', e=> LIFE_MS = parseInt(e.target.value,10));
    // Sound controls
    function primeAudio(){
      try{
        audioPrimed = true;
        ensureAudio();
        loadDefaultTone();
      }catch(_){ }
    }
    document.getElementById('soundEnabled').addEventListener('change', e=>{
      SOUND_ENABLED = !!e.target.checked;
      if (SOUND_ENABLED) { primeAudio(); }
      try{ localStorage.setItem('sound_enabled', SOUND_ENABLED? '1':'0'); }catch(_){ }
    });
    document.getElementById('soundVol').addEventListener('input', e=>{
      SOUND_VOLUME = parseFloat(e.target.value);
      try{ localStorage.setItem('sound_vol', String(SOUND_VOLUME)); }catch(_){ }
    });
    
    // Vibration controls
    function primeVibration(){
      try{
        vibrationPrimed = true;
        ensureVibration();
      }catch(_){ }
    }
    document.getElementById('vibrationEnabled').addEventListener('change', e=>{
      VIBRATION_ENABLED = !!e.target.checked;
      if (VIBRATION_ENABLED) { primeVibration(); }
      try{ localStorage.setItem('vibration_enabled', VIBRATION_ENABLED? '1':'0'); }catch(_){ }
    });
    document.getElementById('fileBtn').addEventListener('click', ()=>{ primeAudio(); document.getElementById('soundFile').click(); });
    document.getElementById('soundFile').addEventListener('change', async e=>{
      const file = e.target.files && e.target.files[0];
      if (!file) return;
      // Simple validation: allow only mp3 and <= 5s
      if (!/mp3$/i.test(file.name)) { alert('Carica un file MP3.'); return; }
      try{
        const buf = await fileToBuffer(file);
        if (buf.duration > 5.0) { alert('Il suono deve essere lungo massimo 5 secondi.'); return; }
        customBuffer = buf;
        try{ localStorage.setItem('sound_custom_name', file.name); }catch(_){ }
        alert('Suono personalizzato caricato.');
      }catch(err){ alert('Impossibile leggere l\'audio.'); }
    });
    document.getElementById('resetBtn').addEventListener('click', async ()=>{
      const ok = await appConfirmRoom({ title:'Reset', message:'Ripristinare impostazioni suono e rendering?' });
      if (!ok) return;
      COLOR = '#00ffaa';
      document.getElementById('color').value = COLOR;
      document.getElementById('spacing').value = 18; SPACING = 18; buildZone();
      document.getElementById('radius').value = 90; RADIUS = 90;
      document.getElementById('life').value = 2000; LIFE_MS = 2000;
      SOUND_ENABLED = true; document.getElementById('soundEnabled').checked = true;
      SOUND_VOLUME = 0.4; document.getElementById('soundVol').value = '0.4';
      customBuffer = null; document.getElementById('soundFile').value = '';
      VIBRATION_ENABLED = true; document.getElementById('vibrationEnabled').checked = true;
      try{ localStorage.removeItem('sound_custom_name'); localStorage.setItem('sound_enabled','1'); localStorage.setItem('sound_vol','0.4'); localStorage.setItem('vibration_enabled','1'); }catch(_){ }
      showToast('Impostazioni ripristinate');
    });

    canvas.addEventListener('pointermove', (e)=>{ const p = toCanvasPos(e); sendHover(p.x, p.y); });
    canvas.addEventListener('touchmove', (e)=>{ const p = toCanvasPos(e); sendHover(p.x, p.y); }, {passive:true});
    // On first gesture, unlock audio and vibration
    canvas.addEventListener('pointerdown', ()=>{ primeAudio(); primeVibration(); }, { once:true });
    canvas.addEventListener('touchstart', ()=>{ primeAudio(); primeVibration(); }, { once:true, passive:true });
    window.addEventListener('resize', resizeCanvas);

    /************ REALTIME ************/
    function setRt(on,msg){
      RT.enabled = !!on;
      const flag = document.getElementById('rtFlag');
      if (flag){
        flag.textContent = on? 'ON':'OFF';
        flag.className = on? 'ok' : 'warn';
      }
      if (msg) console.log('Realtime:', msg);
    }
    function initRealtime(){
      try{
        const dbi  = firebase.database();
        RT.db = dbi;
        const INIT_TS = Date.now();
        const eventsRef = dbi.ref('rooms/'+ROOM+'/events');
        eventsRef.on('child_added', snap=>{
          const ev = snap.val(); if (!ev) return;
          if (ev.client === CLIENT) return;
          // Ignore historical events from before we joined to prevent flash
          if (typeof ev.ts === 'number' && ev.ts < INIT_TS) return;
          if (ev.type === 'hover'){
            const p = ev.payload; 
            applyBrush(p.x, p.y, p.c, p.r);
            // Trigger vibration when other person is drawing
            triggerVibration();
          }
        });
        // Ensure events branch exists so writes don’t fail on missing parent (do not create child that could be rendered)
        eventsRef.once('value', s=>{ if (!s.exists()) eventsRef.set({}); });
        setRt(true, 'stanza #'+ROOM);
      }catch(e){ console.error(e); setRt(false, 'errore init'); }
    }

    // Presence: write my heartbeat under /rooms/<ROOM>/presence/<CLIENT> and watch others
    function initPresence(){
      try{
        const presenceRef = firebase.database().ref('rooms/'+ROOM+'/presence');
        const myRef = presenceRef.child(CLIENT);
        const dot = document.getElementById('presenceDot');

        function updateHeartbeat(){
          myRef.set({ ts: firebase.database.ServerValue.TIMESTAMP });
        }
        // Periodic heartbeat
        updateHeartbeat();
        const hb = setInterval(updateHeartbeat, 4000);

        // Cleanup on disconnect and unload
        myRef.onDisconnect().remove();
        window.addEventListener('beforeunload', ()=>{ try{ clearInterval(hb); myRef.remove(); }catch(_){ } });

        // Watch others: if any other client wrote in the last 10s → online
        presenceRef.on('value', (s)=>{
          const all = s.val() || {};
          const now = Date.now();
          let someoneElseOnline = false;
          for (const k in all){
            if (k === CLIENT) continue;
            const ts = all[k]?.ts || 0;
            if (now - ts <= 10000) { someoneElseOnline = true; break; }
          }
          if (someoneElseOnline){
            dot.classList.add('presence-on');
            dot.setAttribute('title', 'Online');
          } else {
            dot.classList.remove('presence-on');
            dot.setAttribute('title', 'Offline');
          }
        });
        // also watch connection state to refresh heartbeat promptly
        const connectedRef = firebase.database().ref('.info/connected');
        connectedRef.on('value', (snap)=>{ if (snap.val() === true) { updateHeartbeat(); } });
        // Write an initial heartbeat immediately after auth to ensure visibility
        updateHeartbeat();
      }catch(e){ console.warn('presence error', e); }
    }

    /************ BOOT ************/
    resizeCanvas();
    requestAnimationFrame(drawFrame);
    initRealtime();
    initPresence();
    initNotificationListener();
    
    // Request notification permission on room start
    requestRoomNotificationPermission();
    
    // Get and log FCM token
    getFCMToken();
    // default tone will load after first gesture (primeAudio)
    
    // Load saved settings
    try{
      const savedSoundEnabled = localStorage.getItem('sound_enabled');
      if (savedSoundEnabled !== null) {
        SOUND_ENABLED = savedSoundEnabled === '1';
        document.getElementById('soundEnabled').checked = SOUND_ENABLED;
      }
      const savedSoundVol = localStorage.getItem('sound_vol');
      if (savedSoundVol !== null) {
        SOUND_VOLUME = parseFloat(savedSoundVol);
        document.getElementById('soundVol').value = String(SOUND_VOLUME);
      }
      const savedVibrationEnabled = localStorage.getItem('vibration_enabled');
      if (savedVibrationEnabled !== null) {
        VIBRATION_ENABLED = savedVibrationEnabled === '1';
        document.getElementById('vibrationEnabled').checked = VIBRATION_ENABLED;
      }
    }catch(_){ /* ignore localStorage errors */ }
    
    // Initialize Lucide icons
    lucide.createIcons();

    // Modal / Toast elements
    const __ui = (()=>{
      const bg = document.createElement('div');
      bg.className = 'ui-modal-bg';
      bg.innerHTML = '<div class="ui-modal"><h3 id="rtUiTitle" style="margin:0;color:var(--text);font-size:1rem">Conferma</h3><p id="rtUiMsg" style="margin:0;color:var(--text-muted);font-size:.95rem">Sei sicuro?</p><div class="ui-actions"><button id="rtUiCancel" class="ui-btn">Annulla</button><button id="rtUiOk" class="ui-btn primary">OK</button></div></div>';
      document.body.appendChild(bg);
      const toast = document.createElement('div'); toast.style.cssText='position:fixed;right:14px;bottom:14px;background:var(--bg-card);color:var(--text);border:1px solid var(--border);border-radius:12px;padding:10px 12px;z-index:120;display:none'; toast.id='rtToast'; document.body.appendChild(toast);
      return { bg, title:()=>document.getElementById('rtUiTitle'), msg:()=>document.getElementById('rtUiMsg'), ok:()=>document.getElementById('rtUiOk'), cancel:()=>document.getElementById('rtUiCancel'), toast };
    })();
    function showToast(m){ const t=__ui.toast; t.textContent=m; t.style.display='block'; clearTimeout(t.__to); t.__to=setTimeout(()=>{ t.style.display='none'; }, 2200); }
    function appConfirmRoom({title,message}){
      return new Promise(res=>{
        __ui.title().textContent = title||'Conferma';
        __ui.msg().textContent = message||'';
        function close(v){ __ui.bg.style.display='none'; __ui.ok().onclick=null; __ui.cancel().onclick=null; res(v); }
        __ui.ok().onclick=()=> close(true);
        __ui.cancel().onclick=()=> close(false);
        __ui.bg.style.display='flex';
      });
    }

    // Periodic pruning of old events to keep DB small without deleting the room
    (function initPruning(){
      try{
        const EVENTS_TTL_MS = 60000; // keep last 60s of interactions
        const CLEANUP_INTERVAL_MS = 15000; // run every 15s
        const eventsRef = firebase.database().ref('rooms/'+ROOM+'/events');
        async function prune(){
          const cutoff = Date.now() - EVENTS_TTL_MS;
          try {
            const snap = await eventsRef.orderByChild('ts').endAt(cutoff).once('value');
            const old = snap.val() || {};
            const updates = {};
            for (const key in old){ updates[key] = null; }
            if (Object.keys(updates).length){ await eventsRef.update(updates); }
          } catch(e){ /* ignore cleanup errors */ }
        }
        prune();
        setInterval(prune, CLEANUP_INTERVAL_MS);
      }catch(_){ /* ignore */ }
    })();

    // ---------- NOTIFICATION LISTENER FOR ROOM ----------
    let roomNotificationListener = null;
    let roomLastNotificationTimes = {};
    
    function initNotificationListener() {
      const user = auth.currentUser;
      if (!user) return;
      
      // Listen for notifications directed to this user
      roomNotificationListener = db.ref('notifications/'+user.uid);
      
      roomNotificationListener.on('child_added', async (snap) => {
        const notification = snap.val();
        if (!notification || notification.read) return;
        
        try {
          // Check if this is a friend activity notification
          if (notification.type === 'friend_activity' && notification.friendName) {
            const now = Date.now();
            const fiveMinutes = 5 * 60 * 1000;
            const notificationKey = `${notification.fromUserId}_${notification.roomId}`;
            
            // Check throttling (max 1 notification per 5 minutes per friend)
            if (roomLastNotificationTimes[notificationKey] && 
                (now - roomLastNotificationTimes[notificationKey]) < fiveMinutes) {
              // Mark as read and skip
              await snap.ref.update({ read: true });
              return;
            }
            
            // Show notification
            await showRoomNotification(notification);
            
            // Mark as read
            await snap.ref.update({ read: true });
            
            // Update throttling
            roomLastNotificationTimes[notificationKey] = now;
          }
        } catch (error) {
          console.error('Error handling room notification:', error);
        }
      });
    }
    
    async function showRoomNotification(notification) {
      try {
        // Request notification permission if not already granted
        if (Notification.permission === 'default') {
          // First, try to request permission through Android interface (for Android 13+)
          if (window.Android && window.Android.requestNotificationPermission) {
            window.Android.requestNotificationPermission();
          }
          await Notification.requestPermission();
        }
        
        if (Notification.permission === 'granted') {
          // Create the notification
          const notif = new Notification("👀 Someone's looking for you", {
            body: `${notification.friendName} is looking for you 👀`,
            icon: '/logo.png', // Your app icon
            badge: '/logo.png',
            tag: 'interlinked-friend-activity',
            requireInteraction: false,
            silent: false
          });
          
          // Handle notification click
          notif.onclick = () => {
            // If it's a different room, navigate to it
            if (notification.roomId !== ROOM) {
              window.location.href = `room.html#${notification.roomId}`;
            }
            notif.close();
          };
          
          // Auto-close after 5 seconds
          setTimeout(() => {
            notif.close();
          }, 5000);
          
          // Trigger vibration if available
          triggerRoomNotificationVibration();
          
          console.log('Room notification shown for:', notification.friendName);
        } else {
          console.log('Notification permission denied');
        }
      } catch (error) {
        console.error('Error showing room notification:', error);
      }
    }
    
    function triggerRoomNotificationVibration() {
      try {
        // Try Android vibration first
        if (window.Android && window.Android.vibratePattern) {
          const pattern = [0, 200, 100, 200, 100, 200]; // Multiple vibration pattern
          window.Android.vibratePattern(pattern);
          return;
        }
        
        // Fallback to Web Vibration API if available
        if ('vibrate' in navigator) {
          navigator.vibrate([0, 200, 100, 200, 100, 200]);
        }
      } catch (error) {
        console.log('Room vibration not available:', error);
      }
    }
    
    // Request notification permission for room
    async function requestRoomNotificationPermission() {
      try {
        // First, try to request permission through Android interface (for Android 13+)
        if (window.Android && window.Android.requestNotificationPermission) {
          window.Android.requestNotificationPermission();
        }
        
        // Also request web notification permission
        if (Notification.permission === 'default') {
          await Notification.requestPermission();
        }
      } catch (error) {
        console.error('Error requesting room notification permission:', error);
      }
    }

    // ---------- FCM TOKEN INTEGRATION ----------
    async function getFCMToken() {
      try {
        // Try to get FCM token from Android interface first
        if (window.Android && window.Android.getFCMToken) {
          const token = window.Android.getFCMToken();
          if (token) {
            console.log('FCM Token from Android:', token);
            return token;
          }
        }
        
        // Fallback: try to get from Firebase Messaging if available
        if (typeof firebase !== 'undefined' && firebase.messaging) {
          const messaging = firebase.messaging();
          const token = await messaging.getToken();
          if (token) {
            console.log('FCM Token from Firebase:', token);
            return token;
          }
        }
        
        console.log('No FCM token available');
        return null;
      } catch (error) {
        console.error('Error getting FCM token:', error);
        return null;
      }
    }

    // Clean up notification listener when page unloads
    window.addEventListener('beforeunload', () => {
      if (roomNotificationListener) {
        roomNotificationListener.off();
      }
    });
  </script>
</body>
</html>
